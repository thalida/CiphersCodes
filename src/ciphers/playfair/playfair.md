# {{cipher.NAME}}

## About
[{{cipher.NAME}}](http://en.wikipedia.org/wiki/Playfair_cipher) encrypts pairs of letters, using a 5x5 grid.

## Supports
‚ùå Perfect Decoding
‚úÖ Uppercase letters (`A-Z`)
‚úÖ Lowercase letters (`a-z`)
‚ùå Numbers (`0-9`)
‚ùå Symbols (`!@#$`)
‚ùå Emojis (`üòçü§¨üë©üèæ‚Äçüíª`)

**Numbers, Symbols, and Emojis**
Numbers, symbols, and emoji are **outputted as-is** by this cipher.

**No J's**
A limitation of encoding using a 5x5 gris, is there are only 25 potential characters. As a result, most implementations of this cipher combine i and j. This results in all `j`'s being treated as `i`'s when encoding and decoding.

**What is "Perfect Decoding"?**
Perfect Decoding is when the decoded text exactly matches the text that was encoded. This cipher **does not** have perfect decoding, so you'll need to do some mental decoding.

## Source
[View {{cipher.NAME}} on Github](https://github.com/thalida/ciphers.codes/blob/master/src/ciphers/playfair/playfair.js)

---

## Live Example
### Variables
Based on the current settings for {{cipher.NAME}}:
- `key = {{cipher.INPUTS_BY_NAME.key.value}}`
- `cipherAlphabet = {{ utils.makeKeyedAlpha(cipher.INPUTS_BY_NAME.key.value, '', cipher.KEY).join('') }}`

### Sample String
{{ cipher.SAMPLE_STRING }}

### When, **Encoded**
{{ cipher.encodingExample(cipher) }}

### Then, **Decoded**
{{ cipher.decodingExample(cipher) }}

---

## Method

### Required Inputs
`key` is any lowercase string of your choice, it cannot include duplicated letters or any `j`s.

### Keyed Alphabet
Given a `key`, create a new alphabet with that key in front.
For example, with a key of `private` you'll see the cipher alphabet below, in comparison to the standard English alphabet.

The keyed-alphabet (`cipherAlphabet`) generated by the cipher is effectively a shuffled alphabet, with the key at the beginning, that's why the key cannot have duplicate letters.

```js
key = 'private'
// j has been removed from the cipher alphabet
cipherAlphabet = {{ utils.makeKeyedAlpha('private', '', cipher.KEY).join('') }}
standardAlphabet = {{ utils.ALPHA.join('') }}
```

As mentioned, think of the keyed `cipherAlphabet` as a 5x5 grid:
`{{ utils.makeKeyedAlpha('private', '', cipher.KEY).slice(0, 5).join(' ') }}`
`{{ utils.makeKeyedAlpha('private', '', cipher.KEY).slice(5, 10).join(' ') }}`
`{{ utils.makeKeyedAlpha('private', '', cipher.KEY).slice(10, 15).join(' ') }}`
`{{ utils.makeKeyedAlpha('private', '', cipher.KEY).slice(15, 20).join(' ') }}`
`{{ utils.makeKeyedAlpha('private', '', cipher.KEY).slice(20, 25).join(' ') }}`

### Rules
When encoding and decoding, loop over the given string getting pairs of letters at a time. Follow any of the rules below that apply to the pair **before calculating the encoded/decoded character**:
- `j`: Replace it with an `i`
- Double letters: Insert an `x` between the letters
- Odd-length string: if the last character of the string doesn't have a matching pair, use an `x`
- Numbers or Symbols: skip them and output as-is

With those rules `hello` would be encrypted as `he` `lx` `lo` and `juice` as `iu` `ic` `ex`.

_This pre-processing of the string is what causes this cipher to not have perfect decoding!_

### Coordinates
For each letter in the pair, you'll need to calculate the coordinates of the letter in the grid.

Using the `cipherAlphabet` created, here are example 0-indexed coordinates (x, y):
- `h = {{Object.values(cipher.getCoords('h', utils.makeKeyedAlpha('private', '', cipher.KEY))).join(',')}}`
- `e = {{Object.values(cipher.getCoords('e', utils.makeKeyedAlpha('private', '', cipher.KEY))).join(',')}}`
- `l = {{Object.values(cipher.getCoords('l', utils.makeKeyedAlpha('private', '', cipher.KEY))).join(',')}}`
- `x = {{Object.values(cipher.getCoords('x', utils.makeKeyedAlpha('private', '', cipher.KEY))).join(',')}}`

The coordinates are calculated with the following formulas:
```js
{
    x: Math.floor(letterPosition / 5),
    y: letterPosition mod 5
}
```

The formulas below for encoding and decoding reference `x1, y1` and `x2, y2`.
`x1` and `y1` are the coordinates for the first character.
`x2` and `y2` map to the second character coordinates.

### When Encoding
For each pair check which formula they match:

**If the letters are on the same row of the grid** (`x1 == x2`)
```js
encodedCharacterIndex1 = (x1 * 5) + ((y1 + 1) mod 5)
encodedCharacterIndex2 = (x2 * 5) + ((y2 + 1) mod 5)
```

**If the letters are in the same column of the grid** (`y1 == y2`)
```js
encodedCharacterIndex1 = ((x1 + 1) mod 5) * 5) + y1
encodedCharacterIndex2 = ((x2 + 1) mod 5) * 5) + y2
```

**Else, the letters are on a diagonal**
```js
encodedCharacterIndex1 = (x1 * 5) + y2
encodedCharacterIndex2 = (x2 * 5) + y1
```

With the calculated `encodedCharacterIndex1` and `encodedCharacterIndex2`, you can get the new encoded letter at that index in the cipher alphabet.

### When Decoding
For each pair check which formula they match:

**If the letters are on the same row of the grid** (`x1 == x2`)
```js
decodedCharacterIndex1 = (x1 * 5) + ((y1 - 1) mod 5)
decodedCharacterIndex2 = (x2 * 5) + ((y2 - 1) mod 5)
```

**If the letters are in the same column of the grid** (`y1 == y2`)
```js
decodedCharacterIndex1 = ((x1 - 1) mod 5) * 5) + y1
decodedCharacterIndex2 = ((x2 - 1) mod 5) * 5) + y2
```

**Else, the letters are on a diagonal**
```js
decodedCharacterIndex1 = (x1 * 5) + y2
decodedCharacterIndex2 = (x2 * 5) + y1
```

With the calculated `decodedCharacterIndex1` and `decodedCharacterIndex2`, you can get the decoded letter at that index in the cipher alphabet.

### A note on `mod`
This cipher uses `mod 5` which performs the modulo (%) operation. [Javascript doesn't have proper support for mod](https://dev.to/maurobringolf/a-neat-trick-to-compute-modulo-of-negative-numbers-111e) so this formula is used:
```js
export function mod (a, b) {
  return ((a % b) + b) % b
}
```
